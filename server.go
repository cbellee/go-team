package main

import (
	"log"
	"net/http"
	"strconv"

	"github.com/cbellee/go-team/models"
	"github.com/go-playground/validator"
	"github.com/labstack/echo/v4"
	"github.com/labstack/echo/v4/middleware"
	"github.com/swaggo/echo-swagger"

	_ "github.com/swaggo/echo-swagger/example/docs" // docs is generated by Swag CLI, you have to import it.
)

var players = []models.Player{
	models.Player{
		ID:    1,
		Name:  "Chris Bellee",
		Email: "cbellee@microsoft.com",
	},
	models.Player{
		ID:    2,
		Name:  "John Doe",
		Email: "jdoe@gmail.com",
	},
	models.Player{
		ID:    3,
		Name:  "Mark Smith",
		Email: "mark.smith@gmail.com",
	},
	models.Player{
		ID:    4,
		Name:  "Dave White",
		Email: "dave.white@gmail.com",
	},
	models.Player{
		ID:    5,
		Name:  "Josh Pyke",
		Email: "jpyke@gmail.com",
	},
}

var colours = []models.Colour{
	models.Colour{
		Name: "red",
		Code: "#FF0000",
	},
	models.Colour{
		Name: "green",
		Code: "#008000",
	},
	models.Colour{
		Name: "blue",
		Code: "#0000FF",
	},
	models.Colour{
		Name: "yellow",
		Code: "#FFFF00",
	},
	models.Colour{
		Name: "black",
		Code: "#000000",
	},
	models.Colour{
		Name: "white",
		Code: "#FFFFFF",
	},
}

var teams = []models.Team{
	models.Team{
		ID:      1,
		Name:    colours[0].Name,
		Players: []models.Player{players[0]},
		Colour:  colours[0],
	},
	models.Team{
		ID:      2,
		Name:    colours[1].Name,
		Players: []models.Player{players[1], players[2]},
		Colour:  colours[1],
	},
	models.Team{
		ID:      3,
		Name:    colours[2].Name,
		Players: []models.Player{players[3], players[4]},
		Colour:  colours[2],
	},
}

type CustomValidator struct {
	validator *validator.Validate
}

func (cv *CustomValidator) Validate(i interface{}) error {
	return cv.validator.Struct(i)
}

// Players
func findPlayer(id int, p []models.Player) models.Player {
	for _, item := range p {
		if item.ID == id {
			return item
		}
	}
	return models.Player{}
}

// Teams
func findTeam(id int, t []models.Team) models.Team {
	for _, item := range t {
		if item.ID == id {
			return item
		}
	}
	return models.Team{}
}

//e.GET("/teams", getTeam)
func getTeam(c echo.Context) error {
	// Player ID from path `players/:id`
	strId := c.Param("id")
	id, err := strconv.Atoi(strId)
	if err != nil {
		log.Fatal(err)
	}
	t := findTeam(id, teams)
	if t.ID > 0 {
		return c.JSON(http.StatusOK, t)
	} else {
		return c.NoContent(http.StatusNotFound)
	}
}

//e.GET("/teams/:id", getTeams)
func getTeams(c echo.Context) error {
	if len(teams) > 0 {
		return c.JSON(http.StatusOK, teams)
	} else {
		return c.NoContent(http.StatusNotFound)
	}
}

func showTeamByName(c echo.Context) error {
	name := c.QueryParam("name")

	t := findTeamByName(name, teams)
	if len(t.Name) > 0 {
		return c.JSON(http.StatusOK, t)
	} else {
		return c.NoContent(http.StatusNotFound)
	}
}

func showTeamByColour(c echo.Context) error {
	colour := c.QueryParam("colour")

	t := findTeamByColour(colour, teams)
	if len(t.Name) > 0 {
		return c.JSON(http.StatusOK, t)
	} else {
		return c.NoContent(http.StatusNotFound)
	}
}

func findTeamByName(name string, p []models.Team) models.Team {
	for _, item := range p {
		if item.Name == name {
			return item
		}
	}
	return models.Team{}
}

func findTeamByColour(name string, p []models.Team) models.Team {
	for _, item := range p {
		if item.Colour.Name == name {
			return item
		}
	}
	return models.Team{}
}

func createTeam(c echo.Context) error {
	t := new(models.Team)
	if err := c.Bind(t); err != nil {
		return err
	}
	id := len(teams) + 1
	t.ID = id
	teams = append(teams, *t)
	return c.JSON(http.StatusCreated, t)
}

func deleteTeam(c echo.Context) error {
	t := new(models.Team)
	if err := c.Bind(t); err != nil {
		return err
	}
	strId := c.Param("id")
	id, err := strconv.Atoi(strId)
	if err != nil {
		return err
	}
	for i, t := range teams {
		if t.ID == id {
			teams = append(teams[:i], teams[i+1:]...)
		}
	}
	return c.NoContent(http.StatusNoContent)
}

//e.GET("/players/:id", getPlayer)
func getPlayer(c echo.Context) error {
	// Player ID from path `players/:id`
	strId := c.Param("id")
	id, err := strconv.Atoi(strId)
	if err != nil {
		log.Fatal(err)
	}
	p := findPlayer(id, players)
	if p.ID > 0 {
		return c.JSON(http.StatusOK, p)
	} else {
		return c.NoContent(http.StatusNotFound)
	}
}

//e.GET("/players", getPlayers)
func getPlayers(c echo.Context) error {
	if len(players) > 0 {
		return c.JSON(http.StatusOK, players)
	} else {
		return c.NoContent(http.StatusNotFound)
	}
}

func createPlayer(c echo.Context) error {
	p := new(models.Player)
	if err := c.Bind(p); err != nil {
		return err
	}
	id := len(players) + 1
	p.ID = id
	players = append(players, *p)
	return c.JSON(http.StatusCreated, p)
}

func deletePlayer(c echo.Context) error {
	p := new(models.Player)
	if err := c.Bind(p); err != nil {
		return err
	}
	strId := c.Param("id")
	id, err := strconv.Atoi(strId)
	if err != nil {
		return err
	}
	for i, p := range players {
		if p.ID == id {
			players = append(players[:i], players[i+1:]...)
		}
	}
	return c.NoContent(http.StatusNoContent)
}

//e.GET("/players/:email", getPlayer)
func showPlayerByEmail(c echo.Context) error {
	email := c.QueryParam("email")

	p := findPlayerByEmail(email, players)
	log.Println("Player Email: " + p.Email)
	if len(p.Email) > 0 {
		return c.JSON(http.StatusOK, p)
	} else {
		return c.NoContent(http.StatusNotFound)
	}
}

func showPlayerByName(c echo.Context) error {
	name := c.QueryParam("name")

	p := findPlayerByName(name, players)
	log.Println("Player Name: " + p.Name)
	if len(p.Name) > 0 {
		return c.JSON(http.StatusOK, p)
	} else {
		return c.NoContent(http.StatusNotFound)
	}
}

func findPlayerByEmail(email string, p []models.Player) models.Player {
	for _, item := range p {
		if item.Email == email {
			return item
		}
	}
	return models.Player{}
}

func findPlayerByName(name string, p []models.Player) models.Player {
	for _, item := range p {
		if item.Name == name {
			return item
		}
	}
	return models.Player{}
}

// @title Go-Team API
// @version 1.0
// @description This is an API server for summer soccer!
// @termsOfService http://swagger.io/terms/

// @contact.name support_person
// @contact.url http://www.summersoccer.net/support
// @contact.email support@summersoccer.net

// @license.name Apache 2.0
// @license.url http://www.apache.org/licenses/LICENSE-2.0.html

// @host localhost:8080
// @BasePath /v1

func main() {
	e := echo.New()

	e.Validator = &CustomValidator{validator: validator.New()}

	// Middleware
	e.Use(middleware.Logger())
	e.Use(middleware.Recover())

	// swagger endpoint
	e.GET("/swagger/*", echoSwagger.WrapHandler)

	//e.POST("/players", savePlayer)
	e.GET("/players/:id", getPlayer)
	e.GET("/players", getPlayers)
	e.GET("/players/email", showPlayerByEmail)
	e.GET("/players/name", showPlayerByName)
	e.POST("/players", createPlayer)
	//e.PATCH("/players/:id", updatePlayer)
	e.DELETE("/players/:id", deletePlayer)

	//e.POST("/teams", saveTeam)
	e.GET("/teams/:id", getTeam)
	e.GET("/teams", getTeams)
	e.GET("/teams/name", showTeamByName)
	e.GET("/teams/colour", showTeamByColour)
	e.POST("/teams", createTeam)
	//.PATCH("/teams/:id", updateTeam)
	e.DELETE("/teams/:id", deleteTeam)

	e.Logger.Fatal(e.Start(":8080"))
}
